#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <string>
#include <iostream>

#include "ch3d.h"
#include "q3map2.h"

using namespace std;

bool SaveCubeOBJ(std::string fileName, float *verts, unsigned int numPoints, unsigned int *tris, unsigned int numTris)
{
	std::cout << "Saving " << fileName.c_str() << std::endl;

	char fileNameOut[128] = { 0 };
	char tempfileNameOut[128] = { 0 };

	strcpy(tempfileNameOut, fileName.c_str());
	StripFilename(tempfileNameOut);
	StripFilename(tempfileNameOut);
	StripFilename(tempfileNameOut);
	if (strlen(tempfileNameOut) > 0)
	{
		//Sys_Printf("Create %s.\n", tempfileNameOut);
		Q_mkdir(va("%s%s", g_strDirs[0], tempfileNameOut));
	}

	strcpy(tempfileNameOut, fileName.c_str());
	StripFilename(tempfileNameOut);
	StripFilename(tempfileNameOut);
	if (strlen(tempfileNameOut) > 0)
	{
		//Sys_Printf("Create %s.\n", tempfileNameOut);
		Q_mkdir(va("%s%s", g_strDirs[0], tempfileNameOut));
	}

	strcpy(tempfileNameOut, fileName.c_str());
	StripFilename(tempfileNameOut);
	if (strlen(tempfileNameOut) > 0)
	{
		//Sys_Printf("Create %s.\n", tempfileNameOut);
		Q_mkdir(va("%s%s", g_strDirs[0], tempfileNameOut));
	}

#define PATH_MAX 260
	extern char     g_strDirs[VFS_MAXDIRS][PATH_MAX];

	std::ofstream fout(va("%s%s", g_strDirs[0], fileName.c_str()));

	if (fout.is_open())
	{
		fout << "#############################################################\n";
		fout << "#  Convex hull collision model - Generated by WzMap...\n\n";
		fout << "#############################################################\n";

		fout << "#\n";
		fout << "g collision\n";
		fout << "#\n";

		fout << "#\n";
		fout << "# Verts...\n";
		fout << "#\n\n";

		for (size_t v = 0; v < numPoints; v += 3)
		{
			fout << "v " << verts[v + 0] << " "
				<< verts[v + 1] << " "
				<< verts[v + 2] << std::endl;
		}

		fout << "\n";

		fout << "#\n";
		fout << "# Tris...\n";
		fout << "#\n\n";

		for (size_t f = 0; f < numTris; f += 3)
		{
			// UQ1: Seems obj starts indexes at 1, not 0... *shrug*
			fout << "f " << tris[f + 0] + 1 << " "
				<< tris[f + 1] + 1 << " "
				<< tris[f + 2] + 1 << std::endl;
		}

		fout << "\n";

		fout.close();
		return true;
	}
	return false;
}

extern void LoadShaderImages(shaderInfo_t *si);
extern qboolean StringContainsWord(const char *haystack, const char *needle);

void AddQuadStamp2(vec3_t quadVerts[4], unsigned int *numIndexes, unsigned int *indexes, unsigned int *numVerts, vec3_t *xyz)
{
	int             ndx;

	ndx = *numVerts;

	// triangle indexes for a simple quad
	indexes[*numIndexes] = ndx;
	indexes[*numIndexes + 1] = ndx + 1;
	indexes[*numIndexes + 2] = ndx + 3;

	indexes[*numIndexes + 3] = ndx + 3;
	indexes[*numIndexes + 4] = ndx + 1;
	indexes[*numIndexes + 5] = ndx + 2;

	xyz[ndx + 0][0] = quadVerts[0][0];
	xyz[ndx + 0][1] = quadVerts[0][1];
	xyz[ndx + 0][2] = quadVerts[0][2];

	xyz[ndx + 1][0] = quadVerts[1][0];
	xyz[ndx + 1][1] = quadVerts[1][1];
	xyz[ndx + 1][2] = quadVerts[1][2];

	xyz[ndx + 2][0] = quadVerts[2][0];
	xyz[ndx + 2][1] = quadVerts[2][1];
	xyz[ndx + 2][2] = quadVerts[2][2];

	xyz[ndx + 3][0] = quadVerts[3][0];
	xyz[ndx + 3][1] = quadVerts[3][1];
	xyz[ndx + 3][2] = quadVerts[3][2];

	*numVerts += 4;
	*numIndexes += 6;
}

void CreateCube(const vec3_t mins, const vec3_t maxs, unsigned int *numIndexes, unsigned int *indexes, unsigned int *numVerts, vec3_t *verts)
{
	vec3_t quadVerts[4];

	VectorSet(quadVerts[0], mins[0], mins[1], mins[2]);
	VectorSet(quadVerts[1], mins[0], maxs[1], mins[2]);
	VectorSet(quadVerts[2], mins[0], maxs[1], maxs[2]);
	VectorSet(quadVerts[3], mins[0], mins[1], maxs[2]);
	AddQuadStamp2(quadVerts, numIndexes, indexes, numVerts, verts);

	VectorSet(quadVerts[0], maxs[0], mins[1], maxs[2]);
	VectorSet(quadVerts[1], maxs[0], maxs[1], maxs[2]);
	VectorSet(quadVerts[2], maxs[0], maxs[1], mins[2]);
	VectorSet(quadVerts[3], maxs[0], mins[1], mins[2]);
	AddQuadStamp2(quadVerts, numIndexes, indexes, numVerts, verts);

	VectorSet(quadVerts[0], mins[0], mins[1], maxs[2]);
	VectorSet(quadVerts[1], mins[0], maxs[1], maxs[2]);
	VectorSet(quadVerts[2], maxs[0], maxs[1], maxs[2]);
	VectorSet(quadVerts[3], maxs[0], mins[1], maxs[2]);
	AddQuadStamp2(quadVerts, numIndexes, indexes, numVerts, verts);

	VectorSet(quadVerts[0], maxs[0], mins[1], mins[2]);
	VectorSet(quadVerts[1], maxs[0], maxs[1], mins[2]);
	VectorSet(quadVerts[2], mins[0], maxs[1], mins[2]);
	VectorSet(quadVerts[3], mins[0], mins[1], mins[2]);
	AddQuadStamp2(quadVerts, numIndexes, indexes, numVerts, verts);

	VectorSet(quadVerts[0], mins[0], mins[1], mins[2]);
	VectorSet(quadVerts[1], mins[0], mins[1], maxs[2]);
	VectorSet(quadVerts[2], maxs[0], mins[1], maxs[2]);
	VectorSet(quadVerts[3], maxs[0], mins[1], mins[2]);
	AddQuadStamp2(quadVerts, numIndexes, indexes, numVerts, verts);

	VectorSet(quadVerts[0], maxs[0], maxs[1], mins[2]);
	VectorSet(quadVerts[1], maxs[0], maxs[1], maxs[2]);
	VectorSet(quadVerts[2], mins[0], maxs[1], maxs[2]);
	VectorSet(quadVerts[3], mins[0], maxs[1], mins[2]);
	AddQuadStamp2(quadVerts, numIndexes, indexes, numVerts, verts);
}

int inline GetIntersection(float fDst1, float fDst2, vec3_t P1, vec3_t P2, vec3_t &Hit) {
	if ((fDst1 * fDst2) >= 0.0f) return 0;
	if (fDst1 == fDst2) return 0;
	Hit[0] = P1[0] + (P2[0] - P1[0]) * (-fDst1 / (fDst2 - fDst1));
	Hit[1] = P1[1] + (P2[1] - P1[1]) * (-fDst1 / (fDst2 - fDst1));
	Hit[2] = P1[2] + (P2[2] - P1[2]) * (-fDst1 / (fDst2 - fDst1));
	return 1;
}

int inline InBox(vec3_t Hit, vec3_t B1, vec3_t B2, const int Axis) {
	if (Axis == 1 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[1] > B1[1] && Hit[1] < B2[1]) return 1;
	if (Axis == 2 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[0] > B1[0] && Hit[0] < B2[0]) return 1;
	if (Axis == 3 && Hit[0] > B1[0] && Hit[0] < B2[0] && Hit[1] > B1[1] && Hit[1] < B2[1]) return 1;
	return 0;
}

// returns true if line (L1, L2) intersects with the box (B1, B2)
// returns intersection point in Hit
bool CheckLineBox(vec3_t B1, vec3_t B2, vec3_t L1, vec3_t L2, vec3_t &Hit)
{
	if (L2[0] < B1[0] && L1[0] < B1[0]) return false;
	if (L2[0] > B2[0] && L1[0] > B2[0]) return false;
	if (L2[1] < B1[1] && L1[1] < B1[1]) return false;
	if (L2[1] > B2[1] && L1[1] > B2[1]) return false;
	if (L2[2] < B1[2] && L1[2] < B1[2]) return false;
	if (L2[2] > B2[2] && L1[2] > B2[2]) return false;
	if (L1[0] > B1[0] && L1[0] < B2[0] &&
		L1[1] > B1[1] && L1[1] < B2[1] &&
		L1[2] > B1[2] && L1[2] < B2[2])
	{
		Hit[0] = L1[0];
		Hit[1] = L1[1];
		Hit[2] = L1[2];
		return true;
	}
	if ((GetIntersection(L1[0] - B1[0], L2[0] - B1[0], L1, L2, Hit) && InBox(Hit, B1, B2, 1))
		|| (GetIntersection(L1[1] - B1[1], L2[1] - B1[1], L1, L2, Hit) && InBox(Hit, B1, B2, 2))
		|| (GetIntersection(L1[2] - B1[2], L2[2] - B1[2], L1, L2, Hit) && InBox(Hit, B1, B2, 3))
		|| (GetIntersection(L1[0] - B2[0], L2[0] - B2[0], L1, L2, Hit) && InBox(Hit, B1, B2, 1))
		|| (GetIntersection(L1[1] - B2[1], L2[1] - B2[1], L1, L2, Hit) && InBox(Hit, B1, B2, 2))
		|| (GetIntersection(L1[2] - B2[2], L2[2] - B2[2], L1, L2, Hit) && InBox(Hit, B1, B2, 3)))
		return true;

	return false;
}

void CollisionBox(picoModel_t *model, char *fileNameOut)
{
	if (model == NULL)
		return;

	/* each surface on the model will become a new map drawsurface */
	int		numSurfaces = PicoGetModelNumSurfaces(model);

	vec3_t	validHitBounds[2];
	validHitBounds[0][0] = -8192;
	validHitBounds[0][1] = -8192;
	validHitBounds[0][2] = 0;

	validHitBounds[1][0] = 8192;
	validHitBounds[1][1] = 8192;
	validHitBounds[1][2] = 2;

	vec3_t	modelBoundsAroundBase[2];
	float	heightBounds[2];
	heightBounds[0] = 0.0;
	heightBounds[1] = 0.0;
	ClearBounds(modelBoundsAroundBase[0], modelBoundsAroundBase[1]);

	int numHits = 0;

	while (numHits == 0.0 && validHitBounds[1][2] <= 128.0)
	{// Make sure that we find at least some valid bounds to use... but <= 128.0 because we need to give up at some point...
		validHitBounds[1][2] *= 2.0;

		for (int s = 0; s < numSurfaces; s++)
		{
			int				skin = 0;

			/* get surface */
			picoSurface_t	*surface = PicoGetModelSurface(model, s);

			if (surface == NULL)
				continue;

			/* only handle triangle surfaces initially (fixme: support patches) */
			if (PicoGetSurfaceType(surface) != PICO_TRIANGLES)
			{
				Sys_Warning("surface %i (%s) is not a triangles surface.", s, surface->name);
				continue;
			}

			char			*picoShaderName = PicoGetSurfaceShaderNameForSkin(surface, skin);

			shaderInfo_t	*si = ShaderInfoForShader(picoShaderName);

			LoadShaderImages(si);

			if ((si->compileFlags & C_TRANSLUCENT) || (si->compileFlags & C_SKIP) || (si->compileFlags & C_FOG) || (si->compileFlags & C_NODRAW) || (si->compileFlags & C_HINT))
			{
				//Sys_Warning("surface %i (%s) is not a visible surface.", s, surface->name);
				continue;
			}

			if (!(si->compileFlags & C_SOLID))
			{
				//Sys_Warning("surface %i (%s) is not a solid surface.", s, surface->name);
				continue;
			}
			else if (StringContainsWord(picoShaderName, "leaves")
				|| StringContainsWord(picoShaderName, "leaf")
				|| StringContainsWord(picoShaderName, "TreePineForestBranch"))
			{// UQ1: FIXME - Hacky override. Why does it think some leaves are solid? I'm assuming I need to fix some WZ shaders...
			 //Sys_Warning("surface %i (%s) is not a solid surface (tree leaves).", s, surface->name);
				continue;
			}

			//Sys_Warning("surface %i (name %s - shader %s) is a solid surface.", s, surface->name, surface->shader->name);

			/* get info */
			picoIndex_t *idx = PicoGetSurfaceIndexes(surface, 0);

			/* walk the triangle list */
			for (int j = 0; j < PicoGetSurfaceNumIndexes(surface); j += 3, idx += 3)
			{
				picoVec_t *xyzA = PicoGetSurfaceXYZ(surface, idx[0]);
				picoVec_t *xyzB = PicoGetSurfaceXYZ(surface, idx[1]);
				picoVec_t *xyzC = PicoGetSurfaceXYZ(surface, idx[2]);

				if (xyzA[2] < heightBounds[0])
					heightBounds[0] = xyzA[2];
				if (xyzA[2] > heightBounds[1])
					heightBounds[1] = xyzA[2];

				if (xyzB[2] < heightBounds[0])
					heightBounds[0] = xyzB[2];
				if (xyzB[2] > heightBounds[1])
					heightBounds[1] = xyzB[2];

				if (xyzC[2] < heightBounds[0])
					heightBounds[0] = xyzC[2];
				if (xyzC[2] > heightBounds[1])
					heightBounds[1] = xyzC[2];

				vec3_t hit;

				if (CheckLineBox(validHitBounds[0], validHitBounds[1], xyzA, xyzB, hit))
				{
					AddPointToBounds(xyzA, modelBoundsAroundBase[0], modelBoundsAroundBase[1]);
					AddPointToBounds(xyzB, modelBoundsAroundBase[0], modelBoundsAroundBase[1]);
					numHits++;
				}

				if (CheckLineBox(validHitBounds[0], validHitBounds[1], xyzA, xyzC, hit))
				{
					AddPointToBounds(xyzA, modelBoundsAroundBase[0], modelBoundsAroundBase[1]);
					AddPointToBounds(xyzC, modelBoundsAroundBase[0], modelBoundsAroundBase[1]);
					numHits++;
				}

				if (CheckLineBox(validHitBounds[0], validHitBounds[1], xyzB, xyzC, hit))
				{
					AddPointToBounds(xyzB, modelBoundsAroundBase[0], modelBoundsAroundBase[1]);
					AddPointToBounds(xyzC, modelBoundsAroundBase[0], modelBoundsAroundBase[1]);
					numHits++;
				}
			}
		}
	}

	if (numHits <= 0)
	{
		Sys_Warning("Failed to find valid points to generate a collision box for model %s.", model->fileName);
		return;
	}

	// Set mix and max height of the cube to the min/max model heights to extend to the top of the tree...
	modelBoundsAroundBase[0][2] = heightBounds[0];
	modelBoundsAroundBase[1][2] = heightBounds[1];

	unsigned int		numVerts = 0;
	unsigned int		numIndexes = 0;
	vec3_t				*verts = (vec3_t*)malloc(24 * sizeof(vec3_t));
	unsigned int		*indexes = (unsigned int*)malloc(36 * sizeof(unsigned int));

	CreateCube(modelBoundsAroundBase[0], modelBoundsAroundBase[1], &numIndexes, indexes, &numVerts, verts);

	if (numVerts > 0 && numIndexes > 0)
	{
		Sys_Printf("COLLISION: cube model %s. verts %u. indexes %u.\n", model->fileName, numVerts, numIndexes);
		SaveCubeOBJ(fileNameOut, (float *)verts, numVerts*3, indexes, numIndexes);
	}

	free(verts);
	free(indexes);
}
